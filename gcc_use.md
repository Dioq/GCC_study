# GCC Compiler

Linker Options :
-o                              编译后输出文件位置和名称
-g                              在目标文件中添加调试信息，便于gdb调试或objdump反汇编
-no-pie				不使用pie,确保生成的ELF文件 e_type 类型为 ET_EXEC
-L  				指定搜寻库的目录
      				如指定当前目录 gcc -L .
-l    				指定要链接的库的名称
      				加入库的名称是libmylib.a，则gcc -l mylib，即去头去尾。
--static  			组织在链接时使用动态库
--shared 			生成动态库
--static-libgcc  		链接静态libgcc库
--shared-libgcc 		链接动态libgcc库 
--nostdinci			使编译器不再系统缺省的头文件目录里面找头文件,一般和-L联合使用,明确限定头文件的位置。


### 动态连接方式生成可执行程序
gcc x1.c x2.c -o xxx    
### 静态连接的可执行程序
gcc -static x1.c x2.c -o xxx

### 交叉编译使用 Linaro
### linux x86平台下 编译成 arm64 下的可执行文件。(由于arm平台上可能没有对应的动态链接库,所以采用静态编译)
arm-linux-gnueabihf-gcc -static x1.c x2.c -o xxx
or
aarch64-linux-gnu-gcc x1.c x2.c -o xxx


\\ #include <> 直接到系统指定的某些目录中去找某些头文件。
\\ #include "" 先到源文件所在文件夹去找，然后再到系统指定的某些目录中去找某些头文件。
gcc指定头文件的三种情况：
1.会在默认情况下指定到/usr/include文件夹(更深层次的是一个相对路径，gcc可执行程序的路径是/usr/bin/gcc，那么它在实际工作时指定头文件是一种相对路径方法，换算成绝对路径就是加上/usr/include，如#include 就是包含/usr/include/stdio.h)
2.GCC还使用了-L指定路径的方式，即
gcc -L 头文件所在文件夹(绝对路径或相对路径均可) 源文件
举一个例子：
设当前路径为/root/test,其结构如下：
include_test.c
include/include_test.h
有两种方法访问到include_test.h。
1. include_test.c中#include “include/include_test.h”然后gcc include_test.c即可
2. include_test.c中#include 或者#include 然后gcc –L include include_test.c也可
3. 参数：-nostdinc使编译器不再系统缺省的头文件目录里面找头文件,一般和-L联合使用,明确限定头文件的位置。


## 编译相关的知识
静态编译  
静态编译，就是编译器在编译可执行文件的时候，将可执行文件需要调用的对应静态链接库(.a或.lib)中的部分提取出来，链接到可执行文件中去，使可执行文件在运行的时候不依赖于静态链接库。

动态编译  
动态编译的可执行文件需要附带一个动态链接库。在执行时，需要调用其对应动态链接库中的命令。所以其优点一方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。缺点一是哪怕是很简单的程序，>只用到了链接库中的一两条命令，也需要附带一个相对庞大的链接库；二是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行。

静态链接库 
静态链接库就是把(lib)文件中用到的函数代码直接链接进目标程序，程序运行的时候不再需要其它的库文件；

动态链接库 
动态链接库就是把调用的函数所在文件模块（DLL）和调用函数在文件中的位置等信息链接进目标程序，程序运行的时候再从DLL中寻找相应函数代码，因此需要相应DLL文件的支持。

静态链接库和动态链接库的区别  
静态链接库与动态链接库都是共享代码的方式，如果采用静态链接库，则无论你愿不愿意，lib 中的指令都全部被直接包含在最终生成的 EXE 文件中了。但是若使用 DLL，该 DLL 不必被包含在最终 EXE 文件中，EXE 文件执行时可 
以“动态”地引用和卸载这个与 EXE 独立的 DLL 文件。  
静态链接库和动态链接库的另外一个区别在于静态链接库中不能再包含其他的动态链接库或者静态库，而在动态链接库中还可以再包含其他的动态或静态链接库。动态库就是在需要调用其中的函数时，根据函数映射表找到该函数然>后调入堆栈执行。如果在当前工程中有多处对dll文件中同一个函数的调用，那么执行时，这个函数只会留下一份拷贝。但是如果有多处对lib文件中同一个函数的调用，那么执行时，该函数将在当前程序的执行空间里留下多份拷贝>，而且是一处调用就产生一份拷贝。
